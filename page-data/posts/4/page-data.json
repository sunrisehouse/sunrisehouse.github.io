{"componentChunkName":"component---src-page-template-post-tsx","path":"/posts/4/","result":{"pageContext":{"post":{"id":4,"title":"컴퓨터 네트워크","dateString":"2021-03-09","description":"2021년 1학기 컴퓨터 네트워크 수업 정리","mainImageUrl":"","postThemes":[{"name":"summary","id":2}],"html":"<h1 id=\"컴퓨터-네트워크\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC\" aria-label=\"컴퓨터 네트워크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴퓨터 네트워크</h1>\n<p>2021년 1학기 컴퓨터 네트워크 수업을 듣고 나름의 정리를 해보겠다는 생각으로 본 글을 작성하게 됐다.\r\nkeyword 만 듣고 어떤 내용인지 떠올랐으면 좋겠다.</p>\n<h2 id=\"1-introduction\" style=\"position:relative;\"><a href=\"#1-introduction\" aria-label=\"1 introduction permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Introduction</h2>\n<p>네트워크 전반에 관한 내용을 다룬다.</p>\n<ul>\n<li>\n<details>\r\n<summary>networks</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<ul>\n<li>definition: the interconnection of a set of devices capable of communication</li>\n<li>서로 통신할 수 있는 애들 모아놓은 거</li>\n</ul>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>LAN, WAN</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<ul>\n<li>LAN\n<ul>\n<li>local area network</li>\n<li>작은 네트워크</li>\n</ul>\n</li>\n<li>WAN\n<ul>\n<li>wide area network</li>\n<li>큰 네트워크</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>switching</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<ul>\n<li>circuit swich network</li>\n<li>packeet swiched network</li>\n</ul>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>Protocol Layering</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<p><strong>Protocol Layering</strong></p>\n<ul>\n<li>단순화 하기위해 만들어짐</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>TCP/IP Protocol</strong></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">> - 현재 인터넷에서 사용되는 protocol 들\r\n> - 데이터를 전송할 때 source 에서는 multiplexing 을 통해 data 를 계속 capsulation 하고 destination 에서는 demultiplexing 을 통해 data 를 decapsulation 한다\r\n> - |Layer|패킷 이름|주소|프로토콜 들|\r\n  > |---|:---:|:---:|:---:|\r\n  > |**Application**|message|name|HTTP, DNS, FTP ...|\r\n  > |**Transport**|segment, user datagram|port numbers|TCP, UDP|\r\n  > |**Network**|datagram|Logical addresses|IP|\r\n  > |**Data Link**|frame|Link-layer addresses|\r\n  > |**Physical**|bit||</code></pre></div>\n<blockquote>\n<p><strong>OSI 7 계층</strong></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">> - open systems interconnection model\r\n> - TCP/IP Protocol 에서 session, presentation 레이어가 추가됨\r\n> - OSI 의 Application, presentation, session 을 합쳐 TCP/IP 의 Application 으로 생각한다.</code></pre></div>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>Internet</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<ol>\n<li>여러 WAN 과 LAN 으로 구성되어 있는 network</li>\n<li>packet switching 방식</li>\n<li>TCP/IP 프로토콜 사용</li>\n</ol>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n<hr>\n<h2 id=\"2-application-layer\" style=\"position:relative;\"><a href=\"#2-application-layer\" aria-label=\"2 application layer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Application Layer</h2>\n<p>인터넷 사용자들이 사용하지는 서비스들을 제공하는 Layer</p>\n<ul>\n<li>\n<details>\r\n<summary>client-server paradigm vs peer-to-peer paradigm (+ mixed paradigm)</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<table>\n<thead>\n<tr>\n<th>특징</th>\n<th align=\"center\">client-server</th>\n<th align=\"center\">peer-to-pder</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>role</strong></td>\n<td align=\"center\">dedicated server, specific clients</td>\n<td align=\"center\">each <strong>node</strong> can be both server and client</td>\n</tr>\n<tr>\n<td><strong>service</strong></td>\n<td align=\"center\">the server provides services to the client</td>\n<td align=\"center\">each peer can provide and request services</td>\n</tr>\n<tr>\n<td><strong>main purpose</strong></td>\n<td align=\"center\">sharing imformation</td>\n<td align=\"center\">connectivity</td>\n</tr>\n<tr>\n<td><strong>data stored</strong></td>\n<td align=\"center\">in centralized server</td>\n<td align=\"center\">each peer has its own data</td>\n</tr>\n<tr>\n<td><strong>management</strong></td>\n<td align=\"center\">difficult to manage</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td><strong>bottleneck</strong></td>\n<td align=\"center\">more chances of getting bottlenected</td>\n<td align=\"center\">fewer chances of getting bottlenectked</td>\n</tr>\n<tr>\n<td></td>\n<td align=\"center\">server: alwayes on host</td>\n<td align=\"center\">no always on server</td>\n</tr>\n<tr>\n<td></td>\n<td align=\"center\">server has permanent IP address</td>\n<td align=\"center\">peers are intermittently connected and change their IP address</td>\n</tr>\n<tr>\n<td></td>\n<td align=\"center\">provides requested service to client</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td></td>\n<td align=\"center\">highly scalability, increase service capability</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td></td>\n<td align=\"center\">highly distributed and decentralized nature</td>\n<td align=\"center\"></td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<blockquote>\n<p>mixed paradigm</p>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>socket, socket interface</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<p><strong>socket interface</strong></p>\n<ul>\n<li>운영체제에서 제공하는 소켓을 사용하기 위한 명령어들</li>\n<li>application layer 와 운영체제를 연결시켜주는 명령어들</li>\n</ul>\n<p><strong>socket</strong></p>\n<ul>\n<li>data structure</li>\n<li>application layer (process) 에서 os 에 원하는 유형의 socket 만들어달라고 요청하면 os 가 하나 뚝딱해줌</li>\n<li>application layer 에서 만든 소켓에서 원하는 데이터 얻어올 수 있음</li>\n<li>socket address: 32 bit IP address, 16 bit Port number</li>\n</ul>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>UDP, TCP, SCTP</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\">udp</th>\n<th align=\"center\">tcp</th>\n<th align=\"center\">sctp</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">connectionless</td>\n<td align=\"center\">connection-oriented</td>\n<td align=\"center\">connection-oriented</td>\n</tr>\n<tr>\n<td align=\"center\">unreliable</td>\n<td align=\"center\">reliable</td>\n<td align=\"center\">reliable</td>\n</tr>\n<tr>\n<td align=\"center\">datagram</td>\n<td align=\"center\">byte-stream</td>\n<td align=\"center\">multi-stream (by multiple network-layer connection)</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>URL</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<ul>\n<li>protocol + host + port + path</li>\n</ul>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<p>HTTP</p>\n<ul>\n<li>\n<details>\r\n<summary>web documents (static documents, dynamic documents, active documents)</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\">static documents</th>\n<th align=\"center\">dynamic documents</th>\n<th align=\"center\">active documents</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">fixed content documents that are created and stored in a server</td>\n<td align=\"center\">created by a web server whenver a browser request the document</td>\n<td align=\"center\">programs or scripts being run at the client site</td>\n</tr>\n<tr>\n<td align=\"center\">HTML, XML ...</td>\n<td align=\"center\">CGI, JSP, ASP</td>\n<td align=\"center\">javascript</td>\n</tr>\n<tr>\n<td align=\"center\">서버에 저장될 때 그대로 변하지 않는 파일</td>\n<td align=\"center\">클라이언트에서 요청 올 때 변경되는 파일</td>\n<td align=\"center\">클라이언트에서 돌아가는 스크립트나 프로그램</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>HTTP message</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<ul>\n<li>request message = <strong>request line</strong> + header lines + 빈줄 + body</li>\n<li>response message = <strong>status line</strong> + header lines + 빈줄 + body</li>\n<li>\n<img src=\"/images/4-1.png\" width=\"50%\" >\n</li>\n<li><strong>request line</strong> = method + url + version (ex: \"GET /requestFile.html HTTP/1.1\" )</li>\n<li><strong>status line</strong> = version + status code + phrase (ex: \"HTTP/1.1 200 OK\" )</li>\n</ul>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>non persistent vs persitent</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<p>non persistent 는 각각의 request-response 마다 tcp connection 을 만들었다.\r\npersistent 는 tcp connection 을 모든 데이터가 다 주고받을 때까지 닫지 않는다.\r\ntcp 에 있는 handshate 줄일 수 있다.</p>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>HTTP1.0 / HTTP1.1 / HTTP2.0 / HTTP3.0</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\">HTTP1.0</th>\n<th align=\"center\">HTTP1.1</th>\n<th align=\"center\">HTTP2.0</th>\n<th align=\"center\">HTTP3.0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">nonpersistent</td>\n<td align=\"center\">persistent</td>\n<td align=\"center\">persistent</td>\n<td align=\"center\">persistent</td>\n</tr>\n<tr>\n<td align=\"center\">TCP</td>\n<td align=\"center\">TCP</td>\n<td align=\"center\">TCP</td>\n<td align=\"center\">QUIC (UDP)</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">tcp connection 하나 계속 열어놔서 latency 줄였다.</td>\n<td align=\"center\">multiple stream 을 한 tcp connection 에 multiplexing 해서 latency 를 줄였다.</td>\n<td align=\"center\"></td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n</li>\n<li>\n<details>\r\n<summary>FTP</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<p>File Transfer Protocol</p>\n<ul>\n<li>HTTP 도 파일 전송 가능하지만 큰 파일 전송하는 것은 FTP 가 유리</li>\n<li>FTP server 의 구성: server control process, server data process</li>\n<li>FTP network 구조: <img src=\"/images/4-2.png\" width=\"50%\" /></li>\n<li>control connection 이 전체 FTP session 동안 연결되어있다.</li>\n<li>data connection 은 control connection 살아있는 동안에 데이터 전송할 때 연결됐다 닫혔다 한다.</li>\n<li>control connection port 21, data connection port 20</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>data connection 여는 순서</p>\n<ol>\n<li>클라이언트가 임시 포트로 passive open 한다</li>\n<li>클라이언트가 PORT 명령어로 포트 번호 보낸다.</li>\n<li>포트 넘버 받아서 active open 한다.</li>\n</ol>\n</blockquote>\n<blockquote>\n<ul>\n<li>control connection 으로 명령어 주고 받고 data connection 으로 파일 주고받는다.</li>\n<li>FTP 는 파일 가져오고, 파일 저장하고, 파일 directory 하는 세가지 일을 한다.</li>\n</ul>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<p>Email Protocol</p>\n<ul>\n<li>\n<details>\r\n<summary>Email Protocol</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<ul>\n<li>HTTP, FTP 와 다르게 one-way transaction. (HTTP, FTP 는 request, response 처럼 데이터 주고 받고 하는데 그게 아니란 듯)</li>\n<li>네트워크 구조: <img src=\"/images/4-3.png\" width=\"50%\" /></li>\n<li>UA 2개, MTA client-server 2개, MAA client-server 1개</li>\n<li>UA (user agent): 보내고 받는 일 한다. (전자 메일 형식으로 바꿔주는 일도)</li>\n<li>email address: [local part]@[domain name]</li>\n<li>2개의 MTA client-server 의 프로토콜: SMTP</li>\n<li>1개의 MAA client-server 의 프로토콜: POP or IMAP</li>\n<li>MTA(Message Transfer Agent) 에서 메일 보내면 메일 서버에 저장하는 일 하고</li>\n<li>MAA(Message Access Agent) 에서 메일하고 메일 목록 가져오는 일 하는 듯</li>\n</ul>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>SMTP</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<ul>\n<li>Message Transfer Agent</li>\n<li>UA 의 MTA client 에서 자신의 메일 서버에 있는 MTA server 로 메일 보낸다.</li>\n<li>그리고 MTA 서버는 다시 MTA 클라이언트한테 상대방 메일 서버의 MTA server 한테 메일 보낸다.</li>\n<li>명령어가 있다.</li>\n<li>port 25 로 tcp connection 열고 메시지 보내고 연결 닫고</li>\n<li>connection establishment -> message transfer -> connection termination</li>\n<li>메일을 전달하는 세션동안 보내는 사람, 주소등을 알고 있어야하기 때문에 stateful 하다</li>\n</ul>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>POP3 vs IMAP4</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<ul>\n<li>Message Access Agent</li>\n<li>UA 에서 메일 접근하는 프로토콜들</li>\n<li>POP3 (Post Office Protocol) 은 단순</li>\n<li>IMAP4 (Internet Mail Access Protocol) 는 기능 많다.</li>\n<li>메일에 접근하는 세션을 유지해야 하기 때문에 stateful 하다.</li>\n</ul>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>MIME</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<ul>\n<li>SMTP 는 ASCII 만 쓰는데 이제 8 bit 이상의 코드는 MIME 사용</li>\n<li>Network Virtual Terminal (NVT) ASCII 로 바뀌어서 전달된다는 듯</li>\n</ul>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n</li>\n<li>\n<p>Remote logging protocols</p>\n<ul>\n<li>\n<details>\r\n<summary>TELNET</summary>\r\n<div markdown=\"1\">\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>SSH</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<ul>\n<li>Secure Shell</li>\n<li>SSH-1, SSH-2 있고 SSH-1 은 deprecated</li>\n<li>잘모르겠다.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>SSH TRANS (ssh transport layer protocol)</p>\n<ul>\n<li>비밀을 위해</li>\n<li>데이터 무결성 보장</li>\n<li>서버 인증</li>\n<li>메시지 압축 -> 공격 힘들게, 효율적이게</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>SSH AUTH (ssh authentication protocol)</p>\n<ul>\n<li>secure channel 이 만들어지고 authenticate 한다</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>SSH CONN (ssh connection protocol)</p>\n<ul>\n<li>secure channel 만들어지고 authenticate 되고 ssh 는 ssh conn 이 구현된 소프트웨어 조각 실행</li>\n<li>이걸로 여러 가지 한다는 듯</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>ssh for remote logging: putty, tectia</li>\n<li>ssh for file transfer: scp, sftp</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>port forwarding</p>\n<ul>\n<li>secure service 제공 안하는 다른 서비스 (FTP, SMTP...) 등에서 secure channel 이용할 수 있게 ssh 에서 제공하는 서비스</li>\n</ul>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n</li>\n<li>\n<details>\r\n<summary>DNS</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<ul>\n<li>name -> ip address</li>\n<li>mapping 너무 많아서 분산되어있다.</li>\n<li>Hierarchical name space 로 tree 구조로 이루어져있다.</li>\n<li>domain 과 zone <img src=\"/images/4-4.png\" width=\"50%\" /></li>\n<li>domain 은 subtree / zone 은 dns server 가 responsible (or authoritative) 하는 범위</li>\n<li>Internet 의 domain name space 는 세 section 으로 나뉜다: generic domain, country domain, inverse domain (ip 주면 이름 찾아주는 애인데 deprecated 됐다함)</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>IP 주소 찾는 방법</li>\n<li>reculsive resolution: local domain server 가 root server 한테 물어보면 그 서버가 다시 그 아래 server 한테 물어봐서 찾는다.</li>\n<li>interative resolution: local domain server 가 root server 한테 물어보면 그 아래 서버 주수 주고 local domain server 가 찾을 때까지 계속 물어보고 다닌다.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>Resource Rcoreds</p>\n<ul>\n<li>(Domain Name, Type, Class, TTL, Value)</li>\n<li>Domain Name: 리소스 id</li>\n<li>Type: A, NS, CNAME, SOA, MX, AAAA -> value 를 어떻게 받아들일것인지</li>\n<li>Class</li>\n<li>TTL: 정보가 유효한 시간</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>Resource Records Type</p>\n<ul>\n<li>value 를 어떻게 받아들일 것인지</li>\n<li>A 타입이면 32-bit IPv4 address 로</li>\n<li>NS 면 identifies the authoritative servers for a zone</li>\n<li>CNAME 이면 호스트의 공식 이름</li>\n<li>AAAA 면 IPv6 address</li>\n<li>MX 면 메일을 메일 서버로 리다이렉트하는</li>\n<li>SOA 는 zone 의 시작</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>UDP, TCP 둘 다 사용하는데 UDP 는 response message 가 512 바이트보다 작은 경우에 사용</li>\n<li>DDNS 는 동적으로 host 추가했다 삭제했다 ip 바꿨다가 하기 쉽게 만들어짐. (DHCP 이용해서)</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>authoritative name server: hostname to an IP address 하는 공식적인 translation 제공한다.</li>\n<li>local name server: DNS system 으로 proxy 한다. host 가 우선 local name server 한테 mapping 요청한다. 그러면 로컬네임서버가 얻어와서 host 한테 준다.</li>\n</ul>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>Chord</summary>\r\n<div markdown=\"1\">\n<ul>\n<li>each node have finger table (routing table)</li>\n<li>successor: N >= k 중 가장 가까운 N</li>\n<li>predecessor: 전 노드들</li>\n</ul>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>Kademlia</summary>\r\n<div markdown=\"1\">\n<ul>\n<li>두 node 나 key 사이의 거리 구하기 위해 XOR 사용</li>\n<li>가장 가까운 노드가 키를 가지고 있다.</li>\n<li>number of leaves = number of identifiers(node or key)</li>\n<li>routing table 에서 number of rows 는 tree height 만큼</li>\n</ul>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>BitTorrent</summary>\r\n<div markdown=\"1\">\n</div>\n</li>\n</ul>\n</details>\n<h2 id=\"3-transport-layer\" style=\"position:relative;\"><a href=\"#3-transport-layer\" aria-label=\"3 transport layer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Transport Layer</h2>\n<ul>\n<li>Transport layer services</li>\n<li>Transport layer basic protocols</li>\n<li>Internet transport layer protocols\n<ul>\n<li>\n<p>udp</p>\n<ul>\n<li>\n<details>\r\n<summary>datagram (packet name)</summary>\r\n<div markdown=\"1\">\n</div>\n</li>\n</ul>\n</details>\n</li>\n<li>\n<p>tcp</p>\n<ul>\n<li>\n<details>\r\n<summary>segment (packet name)</summary>\r\n<div markdown=\"1\">\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>connection</summary>\r\n<div markdown=\"1\">\n<ul>\n<li>establishment</li>\n<li>data transfer</li>\n<li>termination</li>\n</ul>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>connection</summary>\r\n<div markdown=\"1\">\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>flow control</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<ul>\n<li>send window : open, close, shrink</li>\n<li>recieve window : open, close</li>\n</ul>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>error control</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<ul>\n<li>checksum</li>\n<li>ack</li>\n<li>retransmission: retransmission time out, Tree duplicate ACK Segments (fast retransmission)</li>\n</ul>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n<ul>\n<li>\n<details>\r\n<summary>congestion control</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<ul>\n<li>window size = minimum(rwnd, cwnd)</li>\n<li>cwnd = congestion window</li>\n<li>처음에는 slow start : exponential 하게 증가</li>\n<li>ssthresh 넘어가면 congestion avoidance : 1 씩 증가</li>\n<li>congestion 발생 => fast recovery</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>Taho: congestion 발생하면 ssthresh = cwnd/2 하고 cwnd = 1 로</li>\n<li>Reno: timeout 이면 sshtresh = cwnd/2 하고 cwnd = 1 , 3dupAck 면 ssthresh = cwnd/2 하고 cwnd = ssthresh + 3</li>\n<li>NewReno: slow start 이후에 addictive increase, multiplicative decrease (AIMD)</li>\n<li>Cubic</li>\n</ul>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n</li>\n<li>\n<details>\r\n<summary>quic</summary>\r\n<div markdown=\"1\">\n<blockquote>\n<ul>\n<li>UDP 사용한 apllication layer protocol</li>\n<li>udp connection 하나로 여러 스트림 연결됨</li>\n</ul>\n</blockquote>\n</div>\n</li>\n</ul>\n</details>\n</li>\n</ul>\n<h2 id=\"4-network-layer\" style=\"position:relative;\"><a href=\"#4-network-layer\" aria-label=\"4 network layer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Network Layer</h2>\n<ul>\n<li>IP datagram format</li>\n<li>IPv4 address\n<ul>\n<li>classful addressing</li>\n<li>classless addressing</li>\n<li>network address</li>\n<li>DHCP</li>\n<li>NAT</li>\n<li>Fowarding</li>\n<li>MPLS</li>\n</ul>\n</li>\n</ul>"}}},"staticQueryHashes":[],"slicesMap":{}}