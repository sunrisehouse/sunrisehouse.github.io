{"componentChunkName":"component---src-page-template-post-tsx","path":"/posts/16/","result":{"pageContext":{"post":{"id":16,"title":"Operating System 4 - Process Scheduling","dateString":"2021-12-14","description":"지난 포스트에선 프로세스가 무엇인지부터 시작해서 전반적인 프로세스에 관한 내용을 다루었다. 이번 포스트에서는 프로세스를 스케쥴링하는 기법들에 대해서 작성할 예정이다. 스케줄링 중에서도 프로세서를 할당하는 스케줄링인 medium term scheduling 에 대해서 중점적으로 배웠기 때문에 그 부분을 위주로 작성할 것이다.","mainImageUrl":"/images/12-0.jpeg","postThemes":[{"name":"post","id":1}],"html":"<h1 id=\"operating-system---process-scheduling\" style=\"position:relative;\"><a href=\"#operating-system---process-scheduling\" aria-label=\"operating system   process scheduling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Operating System - Process Scheduling</h1>\n<p>지난 포스트에선 프로세스가 무엇인지부터 시작해서 전반적인 프로세스에 관한 내용을 다루었다. 이번 포스트에서는 프로세스를 스케쥴링하는 기법들에 대해서 작성할 예정이다. 스케줄링 중에서도 프로세서를 할당하는 스케줄링인 medium term scheduling 에 대해서 중점적으로 배웠기 때문에 그 부분을 위주로 작성할 것이다.</p>\n<h2 id=\"1-프로세스-스케줄링\" style=\"position:relative;\"><a href=\"#1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\"1 프로세스 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 프로세스 스케줄링</h2>\n<p>현대 컴퓨터 시스템은 멀티프로그래밍 (멀티 태스킹) 을 지원한다. 시스템에 프로세서보다 많은 수의 프로세스가 돌아간다. 그렇기 때문에 이 프로세스들을 어떻게 관리할지(스케줄링) 에 따라서 성능이 많이 변한다.</p>\n<h2 id=\"2-스케줄링-레벨-scheduling-level\" style=\"position:relative;\"><a href=\"#2-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EB%A0%88%EB%B2%A8-scheduling-level\" aria-label=\"2 스케줄링 레벨 scheduling level permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 스케줄링 레벨 (scheduling level)</h2>\n<ul>\n<li>Long term scheduling: Job 들을 Kernel 에 등록할 때 어떤 Job 을 등록할지</li>\n<li>Medium term scheduling: Swaped out 된 프로세스 중에 어떤 프로세스에 메모리를 할당 시켜줄지</li>\n<li>Short term scheduling: 프로세서 요청중인 프로세스 중에 어떤 프로세스한테 프로세서 할당할지</li>\n</ul>\n<h2 id=\"3-스케줄링-정책-scheduling-policies\" style=\"position:relative;\"><a href=\"#3-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%A0%95%EC%B1%85-scheduling-policies\" aria-label=\"3 스케줄링 정책 scheduling policies permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 스케줄링 정책 (scheduling policies)</h2>\n<ul>\n<li>preemtive vs non-preemtive: 프로세스가 끝나기 전에 다른 프로세스로 바뀔 수 있는지</li>\n<li>static priority vs dynamic priority: 우선순위가 바뀌는지 고정됐는지</li>\n</ul>\n<h2 id=\"4-스케줄링-기법-scheduling-schemes\" style=\"position:relative;\"><a href=\"#4-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EA%B8%B0%EB%B2%95-scheduling-schemes\" aria-label=\"4 스케줄링 기법 scheduling schemes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 스케줄링 기법 (scheduling schemes)</h2>\n<ol>\n<li>FCFS</li>\n<li>RR</li>\n<li>SPN</li>\n<li>SRTN</li>\n<li>HRRN</li>\n<li>priority</li>\n<li>MLQ</li>\n<li>MFQ</li>\n</ol>\n<h3 id=\"41-fcfs-first-come-first-service\" style=\"position:relative;\"><a href=\"#41-fcfs-first-come-first-service\" aria-label=\"41 fcfs first come first service permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.1 FCFS (first come first service)</h3>\n<p>먼저 온 프로세스 먼저 프로세서 사용하고 다 끝나면 다음 프로세스가 사용하는 기법이다. 그렇기 때문에 큰 프로세스가 실행 중이라면 뒤에 많은 프로세스들이 대기하고 있어야 한다. 그렇기 때문에 interactive system 에 적절하지 못하다.</p>\n<ul>\n<li>non-preemtive</li>\n<li>기준: arrival time</li>\n</ul>\n<h3 id=\"42-rr-round-robin\" style=\"position:relative;\"><a href=\"#42-rr-round-robin\" aria-label=\"42 rr round robin permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.2 RR (round robin)</h3>\n<p>먼저 온 프로세스 먼저 프로세서 사용한다. FCFS 와 다른 점은 프로세스가 끝나기 전에 time quantum 을 다 쓰게된다면 쓰고 있던 프로세서를 뺐기고 ready 상태로 들어간다.</p>\n<ul>\n<li>preemtive</li>\n<li>기준: arrival time</li>\n</ul>\n<h3 id=\"43-spn-shortest-process-next\" style=\"position:relative;\"><a href=\"#43-spn-shortest-process-next\" aria-label=\"43 spn shortest process next permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.3 SPN (shortest process next)</h3>\n<p>빨리 끝낼 수 있는 걸 먼저 끝내는 스케줄링 기법이다. 하지만 긴 cpu burst time 을 가진 프로세스는 계속해서 미뤄지다가 실행을 못할 수 도 있다(starvation)(시간이 지날수록 우선순위를 높여주는 aging 으로 해결할 순 있다.)</p>\n<ul>\n<li>non-preemtive</li>\n<li>기준: 프로세스의 남은 cpu burst time</li>\n</ul>\n<h3 id=\"44-srtn-shortest-remaining-time-next\" style=\"position:relative;\"><a href=\"#44-srtn-shortest-remaining-time-next\" aria-label=\"44 srtn shortest remaining time next permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.4 SRTN (shortest remaining time next)</h3>\n<p>빨리 끝낼 수 있는 걸 먼저 끝내는 SPN 의 변형이다. 프로세서를 사용하고 있는 프로세스의 남은 remaining cpu burst time 과 다른 프로세스들의 remaining cpu burst time 을 계속해서 비교해가며 더 짧은 것으로 바꾼다.</p>\n<ul>\n<li>preemtive</li>\n<li>기준: 프로세스의 남은 cpu burst time</li>\n</ul>\n<h3 id=\"45-hrrn-high-response-ratio-next\" style=\"position:relative;\"><a href=\"#45-hrrn-high-response-ratio-next\" aria-label=\"45 hrrn high response ratio next permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.5 HRRN (high response ratio next)</h3>\n<p>빨리 끝낼 수 있는 걸 먼저 끝내지만 많이 기다린 것도 끝낼 수 있게 하는 기법이다.</p>\n<div style=\"text-align:center\">\r\n  <img src=\"/images/16-1.png\" style=\"width:90%; max-width: 400px\" />\r\n</div>\n<ul>\n<li>preemtive, non-preemtive 둘 다 가능</li>\n<li>기준: response ratio</li>\n</ul>\n<h3 id=\"46-priority\" style=\"position:relative;\"><a href=\"#46-priority\" aria-label=\"46 priority permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.6 priority</h3>\n<p>우선순위가 높은 프로세스 부터 프로세서를 할당한다. 우선순위가 같은 경우 tie breaking rule 에 따라서 선택한다. (FCFS 같이 먼저 온 프로세스를 선택할 수도 있다.) 우선순위가 낮은 프로세스는 계속 미뤄지다가 실행이 매우 늦춰질 수 도 있다.</p>\n<ul>\n<li>preemtive, non-preemtive 둘 다 가능</li>\n<li>기준: 프로세스의 priority</li>\n</ul>\n<h3 id=\"47-mlq-multi-level-queue\" style=\"position:relative;\"><a href=\"#47-mlq-multi-level-queue\" aria-label=\"47 mlq multi level queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.7 MLQ (multi level queue)</h3>\n<p>Ready queue 를 여러개로 분리하고 queue 각각에 우선순위를 부여해서 높은 우선순위의 queue 부터 스케줄링하는 기법. 프로세스는 하나의 우선순위 큐를 할당받고 변하지 않는다. 각 queue 는 각각의 스케줄링 기법을 사용해서 프로세스를 선택한다.</p>\n<div style=\"text-align:center\">\r\n  <img src=\"/images/16-2.png\" style=\"width:90%; max-width: 500px\" />\r\n</div>\n<h3 id=\"48-mfq-multi-level-feedback-queue\" style=\"position:relative;\"><a href=\"#48-mfq-multi-level-feedback-queue\" aria-label=\"48 mfq multi level feedback queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.8 MFQ (multi level feedback queue)</h3>\n<p>MLQ 와 마찬가지로 분리된 여러 ready queue 를 운영하는데 프로세스가 어디 ready queue 에 들어갈지 계속 바꾸면서 짧은 cpu burst time 을 갖는 프로세스 먼저 끝나게 하는 기법이다.</p>\n<div style=\"text-align:center\">\r\n  <img src=\"/images/16-3.png\" style=\"width:90%; max-width: 500px\" />\r\n</div>\n<h4 id=\"481-mfq-mechanism\" style=\"position:relative;\"><a href=\"#481-mfq-mechanism\" aria-label=\"481 mfq mechanism permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.8.1 MFQ mechanism</h4>\n<ol>\n<li>맨 처음 프로세스가 진입하면 가장 높은 우선순위를 갖는 큐로 들어간다.</li>\n<li>프로세서 할당받은 프로세스가 IO 하러 가면 (IO 를 많이 하면) 큐 유지.</li>\n<li>프로세서 할당받은 프로세스가 preemt 되면 (cpu 많이 쓰면) 우선순위 낮춘다.</li>\n<li>마지막 큐에 있는 프로세스는 그대로 유지.</li>\n</ol>\n<h4 id=\"482-mfq-variation\" style=\"position:relative;\"><a href=\"#482-mfq-variation\" aria-label=\"482 mfq variation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.8.2 MFQ variation</h4>\n<p>낮은 우선순위 큐에 들어가있는 프로세스는 올라올 방법이 없기 때문에 starvation 이 일어날 수 있다. 그리고 오버헤드가 크다. 그래서 variation 을 줘서 해결할 수 있다.</p>\n<ul>\n<li>각 ready queue 마다 다른 time quantum 사용하기</li>\n<li>aging: 오래 기다린 프로세스 더 높은 우선순위의 queue 에 배정</li>\n<li>IO bound process 는 우선하기 위해 io 하러간 프로세스는 wake up 때 더 높은 우선순위 queue 에 배정</li>\n</ul>\n<h2 id=\"5-case-study\" style=\"position:relative;\"><a href=\"#5-case-study\" aria-label=\"5 case study permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Case Study</h2>\n<h3 id=\"51-unix\" style=\"position:relative;\"><a href=\"#51-unix\" aria-label=\"51 unix permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5.1 Unix</h3>\n<p>MFQ 와 유사한 스케줄링 기법을 사용한다. kernel mode 에 있는 프로세스의 우선순위(kernel priority) user mode 에 있는 프로세스의 우선순위 (user priority) 로 나뉜다. kernel 전체 시스템의 프로세스들의 우선순위를 판단해서 주기적으로 프로세스를 interrupt 한다.</p>\n<div style=\"text-align:center\">\r\n  <img src=\"/images/16-4.png\" style=\"width:90%; max-width: 500px\" />\r\n</div>\n<p>우선순위는 cpu count 에 반비례해서 io bound 를 선호하게 한다. (아래 식에 있는 priority 값이 낮을 수록 우선순위가 높다.) 일정 주기마다 1/2 하면서 starvation 을 예방한다.</p>\n<div style=\"text-align:center\">\r\n  <img src=\"/images/16-5.png\" style=\"width:90%; max-width: 300px\" />\r\n</div>\n<p>FSS 라는 기법도 사용하는데 프로세스마다가 아닌 user 기준으로 프로세스의 그룹을 지어서 user 마다 프로세서를 똑같이 할당받을 수 있게 하는 기법이다. (user 한명이 프로세스 많이 쓰면 다른 user 는 프로세서 사용을 많이 못하니까)</p>\n<h3 id=\"52-windows\" style=\"position:relative;\"><a href=\"#52-windows\" aria-label=\"52 windows permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5.2 Windows</h3>\n<p>6가지 우선순위 분류(priority classes)가 있다. 각 클래스마다 상대적인 우선순위(relative priorities)가 있다. 이 우선순위들을 변화시키면서 스케줄링을 진행한다.</p>\n<div style=\"text-align:center\">\r\n  <img src=\"/images/16-6.png\" style=\"width:90%; max-width: 300px\" />\r\n</div>\n<h3 id=\"53-linux\" style=\"position:relative;\"><a href=\"#53-linux\" aria-label=\"53 linux permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5.3 Linux</h3>\n<h4 id=\"531-version\" style=\"position:relative;\"><a href=\"#531-version\" aria-label=\"531 version permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5.3.1 version</h4>\n<p>~ v2.4</p>\n<ul>\n<li>예전 unix 기법의 변형을 사용했다.</li>\n<li>SMP 를 지원하지 않는다.</li>\n<li>No scalability (in scheduling) for the number of tasks</li>\n</ul>\n<p>~ v2.6.22</p>\n<ul>\n<li>SMP 지원</li>\n</ul>\n<p>v2.6.23 ~</p>\n<ul>\n<li>CFS(Completely Fair Scheduler): Implementation of a well-studied, classic scheduling algorithm,called fair queuing(fair scheduling) (red black tree 로 구현)</li>\n</ul>\n<h4 id=\"532-priority-ranges\" style=\"position:relative;\"><a href=\"#532-priority-ranges\" aria-label=\"532 priority ranges permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5.3.2 priority ranges</h4>\n<p>0 ~ 139 까지의 우선순위를 가지고 있고 값이 낮을 수록 우선순위가 높다. 0 ~ 99 까지 real time range 이고 100 ~ 139 까지 non-real time range 이다.</p>\n<div style=\"text-align:center\">\r\n  <img src=\"/images/16-8.png\" style=\"width:90%; max-width: 200px\" />\r\n</div>\n<p>각 real time range 에서는 우선순위 별로 queue 를 가지고 있고 non-real time range 에서는 red black tree 구조로 ready queue 를 구현했다. (CFS)</p>\n<div style=\"text-align:center\">\r\n  <img src=\"/images/16-7.png\" style=\"width:90%; max-width: 200px\" />\r\n</div>\n<h2 id=\"6-multiple-processor-scheduling\" style=\"position:relative;\"><a href=\"#6-multiple-processor-scheduling\" aria-label=\"6 multiple processor scheduling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. Multiple Processor Scheduling</h2>\n<h3 id=\"61-processor-affinity\" style=\"position:relative;\"><a href=\"#61-processor-affinity\" aria-label=\"61 processor affinity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6.1 processor affinity</h3>\n<p>프로세스가 사용 중이던 프로세서 말고 다른 프로세서에서 실행되게 되면 overhead 가 크다. 그래서 최대한 같은 프로세서에서 실행될 수 있도록 하는 방법이다. 하지만 너무 한 프로세서만 바쁘면 옮겨질 수도 있다(soft affinity). 아예 옮기면 안되는 방법은 hard affinity 라고 한다.</p>\n<h3 id=\"62-load-balancing\" style=\"position:relative;\"><a href=\"#62-load-balancing\" aria-label=\"62 load balancing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6.2 load balancing</h3>\n<p>최대한 고르게 프로세서에 프로세스를 할당할 수 있도록 하는 방법이다.</p>\n<ul>\n<li>Push migration: 특정 task 가 계속 프로세서들의 load 를 모니터링하다가 불균형이 발견되면 많은 프로세스를 갖고있는 프로세서에서 적은 프로세스를 갖고있는 프로세서로 push</li>\n<li>Pull migration: 제일 적은 프로세서가 많으 프로세서한테 프로세스를 땡겨온다.</li>\n</ul>\n<p>보통 둘 다 사용한다.</p>"}}},"staticQueryHashes":[],"slicesMap":{}}