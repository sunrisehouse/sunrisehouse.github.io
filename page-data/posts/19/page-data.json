{"componentChunkName":"component---src-page-template-post-tsx","path":"/posts/19/","result":{"pageContext":{"post":{"id":19,"title":"Operating System 7 - Memory Management","dateString":"2021-12-17","description":"운영체제는 실행된 프로세스를 관리하기 위해 프로세스에 관한 정보들 (예를 들어 프로세스의 코드들, 프로그램 데이터들(전역, 정적 변수), heap, stack) 을 메모리에 저장한다. 그런데 운영체제에는 여러 프로세스가 있기 때문에 이러한 데이터들을 메모리에서 어떻게 관리해야 효율적으로 관리할 수 있는지 정리해보자.","mainImageUrl":"/images/12-0.jpeg","postThemes":[{"name":"post","id":1}],"html":"<h1 id=\"memory-manaement\" style=\"position:relative;\"><a href=\"#memory-manaement\" aria-label=\"memory manaement permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Memory Manaement</h1>\n<p>운영체제는 실행된 프로세스를 관리하기 위해 프로세스에 관한 정보들 (예를 들어 프로세스의 코드들, 프로그램 데이터들(전역, 정적 변수), heap, stack) 을 메모리에 저장한다. 그런데 운영체제에는 여러 프로세스가 있기 때문에 이러한 데이터들을 메모리에서 어떻게 관리해야 효율적으로 관리할 수 있는지 정리해보자.</p>\n<h2 id=\"1-background\" style=\"position:relative;\"><a href=\"#1-background\" aria-label=\"1 background permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Background</h2>\n<p>컴퓨터 시스템의 메모리에는 프로세서 레지스터, 캐쉬 메모리, 메인 메모리, 보조 기억장치 등이 있다.</p>\n<p>Data transfer unit</p>\n<ul>\n<li>Block: 메인 메모리 - 보조 기억장치</li>\n<li>Word: 프로세서 - 메인 메모리</li>\n</ul>\n<p>프로세서에 가까울 수록 access time 빠르고 용량 작다.</p>\n<p>Address Binding: 명령어들 중에 상대 주소로 jump 하는 경우는 상관 없지만 절대 주소로 jump 하는 경우가 있다. 그런데 실제 메모리에 올라갈 때는 시작 주소가 다르니까 문제가 생긴다. 그러므로 이제 binding 이 필요하다.</p>\n<ul>\n<li>compile time binding: 프로세스가 메모리 어디에 매핑될지 아는 경우에 시작 주소를 더해준다.</li>\n<li>load time binding: 로드 시에</li>\n<li>run time binding: 런타임 시에 하드웨어에서 메모리에 매핑된 주소를 계산해서 바인딩한다. (하드웨어 지원 필요)</li>\n</ul>\n<p>Dynamic Linking</p>\n<ul>\n<li>linking 이 excution 할 때 일어나는 것</li>\n</ul>\n<p>Swapping</p>\n<ul>\n<li>프로세스는 일시적으로 메모리 뺏기고 보조 기억장치의 swap device 란 곳에 swaped out 될 수 있다.</li>\n</ul>\n<div style=\"text-align:center\">\r\n  <img src=\"/images/19-1.png\" style=\"width:90%; max-width: 200px\" />\r\n</div>\n<h2 id=\"2-memory-management-방법\" style=\"position:relative;\"><a href=\"#2-memory-management-%EB%B0%A9%EB%B2%95\" aria-label=\"2 memory management 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Memory Management 방법</h2>\n<p>Contiguous allocation</p>\n<ul>\n<li>Uniprogramming</li>\n<li>FPM/VPM</li>\n</ul>\n<div style=\"text-align:left\">\r\n  <img src=\"/images/19-2.png\" style=\"width:90%; max-width: 200px\" />\r\n</div>\n<p>Discontiguous allocation</p>\n<ul>\n<li>Paging</li>\n<li>Segmentation</li>\n</ul>\n<div style=\"text-align:left\">\r\n  <img src=\"/images/19-3.png\" style=\"width:90%; max-width: 200px\" />\r\n</div>\n<p>Virtual memory</p>\n<ul>\n<li>Paging (Demand paging)</li>\n<li>Segmentation</li>\n</ul>\n<div style=\"text-align:left\">\r\n  <img src=\"/images/19-4.png\" style=\"width:90%; max-width: 200px\" />\r\n</div>\n<h2 id=\"3-contiguousmemory-allocation\" style=\"position:relative;\"><a href=\"#3-contiguousmemory-allocation\" aria-label=\"3 contiguousmemory allocation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. ContiguousMemory Allocation</h2>\n<p>프로세스에 관한 데이터들을 한 섹션에 저장</p>\n<h4 id=\"31-unimprogramming\" style=\"position:relative;\"><a href=\"#31-unimprogramming\" aria-label=\"31 unimprogramming permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1 Unimprogramming</h4>\n<p>메모리에 프로세스가 한 개 존재한다. 커널 부분에 접근하지 않게 하기위해 메모리 접근할 때 kernel boundary 와 비교해서 보호.</p>\n<div style=\"text-align:center\">\r\n  <img src=\"/images/19-5.png\" style=\"width:90%; max-width: 300px\" />\r\n</div>\n<p>만약 메모리보다 프로세스의 크기가 더 크다면 오버레이 구조를 이용해서 메모리에 공통된 부분은 놔두고 섹션을 나눠서 메모리에 넣어놨다가 갈아끼는 식으로 구현</p>\n<div style=\"text-align:center\">\r\n  <img src=\"/images/19-6.png\" style=\"width:90%; max-width: 400px\" />\r\n</div>\n<h4 id=\"32-fixed-partition-multiprogramming\" style=\"position:relative;\"><a href=\"#32-fixed-partition-multiprogramming\" aria-label=\"32 fixed partition multiprogramming permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2 Fixed Partition Multiprogramming</h4>\n<p>메모리를 여러 크기의 파티션으로 나눠서 프로세스가 메모리 할당받을 때 파티션 중에 하나 택해서 들어가는 방법이다. 메모리 관리가 쉽지만 메모리 활용 효울이 낮다.</p>\n<p>프로세스의 크기와 파티션의 크기가 맞지 않아서 파티션 안의 낭비되는 곳이 있다(internal fragmentation). 그리고 낭비되는 공간들을 다 합하면 새로 프로세스하나 더 들어갈 수도 있으니 그렇게도 낭비가 된다 (external fragmentation).</p>\n<div style=\"text-align:center\">\r\n  <img src=\"/images/19-7.png\" style=\"width:90%; max-width: 300px\" />\r\n</div>\n<h4 id=\"33-variable-partition-multiprogramming\" style=\"position:relative;\"><a href=\"#33-variable-partition-multiprogramming\" aria-label=\"33 variable partition multiprogramming permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.3 Variable Partition Multiprogramming</h4>\n<p>메모리 파티션의 크기가 들어오는 프로세스 크기에 따라서 달라진다.</p>\n<div style=\"text-align:center\">\r\n  <img src=\"/images/19-8.png\" style=\"width:90%; max-width: 400px\" />\r\n</div>\n<p>Placement strategies: 프로세스가 들어오면 빈 파티션 중 어디에 놔야할지 정해야한다.</p>\n<ol>\n<li>first fit: 빈 공간 찾다가 들어갈 수 있는 파티션에 바로 들어가기</li>\n<li>best fit: 전체 빈 공간 한번 다 둘러보고 크기가 딱 맞는 곳에 들어가기</li>\n<li>worst fit: 전체 빈 공간 한번 다 둘러보고 제일 큰 데에 들어가기. small size partitions 수를 줄일 수 있다.</li>\n<li>next fit: 이전에 찾은 데 이후부터 찾기 (first fit 이랑 유사)</li>\n</ol>\n<p>빈 파티션이 너무 자잘하게 많아지면 문제가 효율이 안좋아진다.</p>\n<ol>\n<li>인접한 빈 파티션을 합치기</li>\n<li>빈 파티션 모조리 다 하나로 합치기, 많은 시스템 자원을 쓴다.</li>\n</ol>\n<h2 id=\"4-discontiguous-memory-allocation\" style=\"position:relative;\"><a href=\"#4-discontiguous-memory-allocation\" aria-label=\"4 discontiguous memory allocation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Discontiguous Memory Allocation</h2>\n<h4 id=\"41-paging\" style=\"position:relative;\"><a href=\"#41-paging\" aria-label=\"41 paging permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.1 Paging</h4>\n<div style=\"text-align:center\">\r\n  <img src=\"/images/19-9.png\" style=\"width:90%; max-width: 400px\" />\r\n</div>\n<p>Physical 메모리를 Frame (page frame) 으로 Logical 메모리를 page 로 나눠서 메모리를 관리하는 방법이다. 프로세스가 메모리에 올라갈 때 프로세스 이미지를 페이지 단위로 나눠서 메모리에 저장한다. 나뉜 프로세스 이미지들이 메모리의 어떤 페이지에 들어있는지 기록하기 위해 Page Map Table 에 기록한다.</p>\n<p>logical 주소 v = (p, d)</p>\n<p>p 를 page map table 에 넣어서 f (page frame number) 를 찾는다. d (offset) 은 그대로 사용한다.</p>\n<p>physical 주소 a = (f, d)</p>\n<h4 id=\"42-segmentation\" style=\"position:relative;\"><a href=\"#42-segmentation\" aria-label=\"42 segmentation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.2 Segmentation</h4>\n<div style=\"text-align:center\">\r\n  <img src=\"/images/19-10.png\" style=\"width:90%; max-width: 400px\" />\r\n</div>\n<p>프로세스 이미지를 logical 한 영역들로 나눈다. 메모리도 variable sized segments 로 나눠서 관리한다. 프로세스 이미지의 각 logical 영역들이 어디 segment 에 있는지 segment table 에 저장한다.</p>\n<p>logical 주소 v = (s, d)</p>\n<p>s 를 segment table 에 넣어서 b (base line 주소) 를 찾는다. d (offset) 은 그대로 사용한다.</p>\n<p>physical 주소 a = (b, d)</p>\n<h2 id=\"5-virtual-memory-allocation\" style=\"position:relative;\"><a href=\"#5-virtual-memory-allocation\" aria-label=\"5 virtual memory allocation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Virtual Memory Allocation</h2>\n<p>은 다음 포스트에서 계속 ~</p>"}}},"staticQueryHashes":[],"slicesMap":{}}